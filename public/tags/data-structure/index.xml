<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>data-structure on Today I Learned</title>
    <link>https://todayilearned.dev/tags/data-structure/</link>
    <description>Recent content in data-structure on Today I Learned</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 15 Jul 2019 09:00:10 -0400</lastBuildDate>
    
	<atom:link href="https://todayilearned.dev/tags/data-structure/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>merkle tree</title>
      <link>https://todayilearned.dev/posts/merkle-tree/</link>
      <pubDate>Mon, 15 Jul 2019 09:00:10 -0400</pubDate>
      
      <guid>https://todayilearned.dev/posts/merkle-tree/</guid>
      <description>TIL about the merkle tree data structure, a tree structure in which each leaf node is a hash of a block of data, and each non-leaf node is a hash of its children.
Label ROOT Value H(H01 + H23) / \ Label [H01] [H23] Value H(H0 + H1) H(H2 + H3) / \ / \ Label [H0] [H1] [H2] [H3] Value H(A) H(B) H(C) H(D) | | | | A B C D It&amp;rsquo;s mostly used in distributed systems for efficient data verification since it only depends on hashes instead of full files.</description>
    </item>
    
    <item>
      <title>ulids</title>
      <link>https://todayilearned.dev/posts/ulids/</link>
      <pubDate>Mon, 29 Apr 2019 08:30:10 -0400</pubDate>
      
      <guid>https://todayilearned.dev/posts/ulids/</guid>
      <description>TIL about ULID, which stands for &amp;ldquo;Universally Unique Lexicographically Sortable Identifier&amp;rdquo;. Like UUID, ULID have 128 bits but are represented as a 26 character string, as opposed to 36.
An ULID is composed of a timestamp + random sequence of bits:
01AN4Z07BY 79KA1307SR9X4MV3 |----------| |----------------| Timestamp Randomness 48bits 80bits  It gives the system the possibility of sorting identifiers unlike UUIDs, but still makes it difficult to guess an identifier and the amount of resources our system has, which are two potential problems of using sequential ids.</description>
    </item>
    
    <item>
      <title>roaring bitmap</title>
      <link>https://todayilearned.dev/posts/roaring-bitmap/</link>
      <pubDate>Sat, 13 Apr 2019 19:50:10 -0400</pubDate>
      
      <guid>https://todayilearned.dev/posts/roaring-bitmap/</guid>
      <description>TIL about roaring bitmap, a hybrid data structure.
It&amp;rsquo;s a data structure that is especially suited to compute the intersection, union and the difference between sets. It uses different approaches depending on how your data is distributed like uncompressed bitmaps or sorted arrays.
The way this is done is by dividing the data into chunks of 2^16 integers and using a different strategy for each chunk depending on the data distribution.</description>
    </item>
    
  </channel>
</rss>