<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on Today I Learned</title>
    <link>https://todayilearned.dev/tags/algorithm/</link>
    <description>Recent content in algorithm on Today I Learned</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 01 Mar 2020 22:33:17 -0400</lastBuildDate>
    
	<atom:link href="https://todayilearned.dev/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>floyd&#39;s tortoise and hare algorithm</title>
      <link>https://todayilearned.dev/posts/floyd-tortoise-hare/</link>
      <pubDate>Sun, 01 Mar 2020 22:33:17 -0400</pubDate>
      
      <guid>https://todayilearned.dev/posts/floyd-tortoise-hare/</guid>
      <description>TIL about Floyd&amp;rsquo;s Tortoise and Hare algorithm.
This algorithm is used to detect whether there is a cycle in a list, and given that a cycle exists its starting point and the length of the cycle.
The algorithm can also be used to prove the existence of duplicate numbers in a list.
The time complexity of this algorithm is linear: O(n). The space complexity of this algorithm is constant: O(1).</description>
    </item>
    
    <item>
      <title>count min sketch</title>
      <link>https://todayilearned.dev/posts/count-min-sketch/</link>
      <pubDate>Sun, 22 Sep 2019 09:12:35 -0400</pubDate>
      
      <guid>https://todayilearned.dev/posts/count-min-sketch/</guid>
      <description>TIL about Count-Min Sketch, an algorithm used to answer questions like:
 What’s the frequency of our samples? What’s our most frequent samples?  Similar to bloom filters, it uses k distinct hash functions. Every observed value serves as an input for these functions and the output for each function is a number corresponding to a bucket.After finding the buckets we just need to increment a counter in each of these buckets.</description>
    </item>
    
    <item>
      <title>cuckoo filter</title>
      <link>https://todayilearned.dev/posts/cuckoo-filter/</link>
      <pubDate>Mon, 24 Jun 2019 09:00:10 -0400</pubDate>
      
      <guid>https://todayilearned.dev/posts/cuckoo-filter/</guid>
      <description>TIL about cuckoo filter, a similar algorithm to bloom filters. Both algorithms support fast set membership testing, but cuckoo filters expand on this concept by providing limited counting, deletion and a bounded false positive probability while maintaining a similar space complexity.
cuckoo filters do not play nice with concurrency.</description>
    </item>
    
    <item>
      <title>power of two choices</title>
      <link>https://todayilearned.dev/posts/power-of-two-choices/</link>
      <pubDate>Fri, 17 May 2019 20:50:10 -0400</pubDate>
      
      <guid>https://todayilearned.dev/posts/power-of-two-choices/</guid>
      <description>TIL about the Power of Two Choices algorithm used in load balancing, queuing theory and distributed systems in general.
The main takeaway is that it is better to pick two queues at random and choose the one with the least amount of work than finding the best queue and sending a workload there. Why? If we are dealing with many decision makers (as in distributed load balancers for example) and each one choose the best queue disregarding each other choices then all their choices will go to the same queue, overwhelming it.</description>
    </item>
    
  </channel>
</rss>