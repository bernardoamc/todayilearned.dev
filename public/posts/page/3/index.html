<!DOCTYPE html>
<html lang="en-us">
    <head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<title>
				Posts &middot; Today I Learned
		</title>

		
  	<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">
		<link rel="stylesheet" href="/header.css">
		
	    <script src="content/clipboard.min.js"></script>

    	<script>
        window.onload = function() {
          const clipboard = new ClipboardJS('.permalink button');
          const toast = document.querySelector('.toast');

          let timeout = -1;
          clipboard.on('success', function(e) {
            toast.classList.add('open');
            clearTimeout(timeout);
            timeout = setTimeout(function() {
            	toast.classList.remove('open')
            }, 2000);
          });
        }

      </script>

		
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="https://todayilearned.dev/posts/index.xml" rel="alternate" type="application/rss+xml" title="Today I Learned" />
	</head>


    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<h2 class="nav-title">Today I Learned</h2>
				</a>

				<ul>
    <li><a href="/topics">Topics</a></li>
</ul>

			</div>
		</nav>

        

<main>
	<div class="catalogue">
		
			<a href="https://todayilearned.dev/posts/rum-index/" class="catalogue-item">
    <div>
        <time datetime="2019-05-22 21:30:10 -0400 EDT" class="catalogue-time">May 22, 2019</time>
        <h1 class="catalogue-title">rum index</h1>
        <div class="catalogue-line"></div>

        <p>
            TIL about the RUM index extension in PostgreSQL. It is a variant of the GIN index that stores additional information in the posting tree like lexemes position and timestamps. This solves known GIN problems like slow ranking and phrase searching.
The drawback of course is that this additional information incurs extra build and insert time, making it not ideal for tables that change often.
        </p>
    </div>
</a>

		
			<a href="https://todayilearned.dev/posts/power-of-two-choices/" class="catalogue-item">
    <div>
        <time datetime="2019-05-17 20:50:10 -0400 EDT" class="catalogue-time">May 17, 2019</time>
        <h1 class="catalogue-title">power of two choices</h1>
        <div class="catalogue-line"></div>

        <p>
            TIL about the Power of Two Choices algorithm used in load balancing, queuing theory and distributed systems in general.
The main takeaway is that it is better to pick two queues at random and choose the one with the least amount of work than finding the best queue and sending a workload there. Why? If we are dealing with many decision makers (as in distributed load balancers for example) and each one choose the best queue disregarding each other choices then all their choices will go to the same queue, overwhelming it.
        </p>
    </div>
</a>

		
			<a href="https://todayilearned.dev/posts/bsearch/" class="catalogue-item">
    <div>
        <time datetime="2019-05-15 08:00:45 -0400 EDT" class="catalogue-time">May 15, 2019</time>
        <h1 class="catalogue-title">bsearch</h1>
        <div class="catalogue-line"></div>

        <p>
            TIL that we have a builtin bsearch in the Array class. It&rsquo;s common for Rubyists to default to find, but as we know bsearch performs much better when we have a sorted Array.
Let&rsquo;s see an example:
ary = [0, 4, 7, 10, 12] ary.bsearch {|x| x &gt;= 4 } #=&gt; 4 ary.bsearch {|x| x &gt;= -1 } #=&gt; 0 We can also use it to search String objects, but in this case we need to use the &lt;=&gt; operator in order to return -1, 0 or 1.
        </p>
    </div>
</a>

		
			<a href="https://todayilearned.dev/posts/amdahl-law/" class="catalogue-item">
    <div>
        <time datetime="2019-05-09 18:45:10 -0400 EDT" class="catalogue-time">May 9, 2019</time>
        <h1 class="catalogue-title">amdahl&#39;s law</h1>
        <div class="catalogue-line"></div>

        <p>
            TIL about Amdahl&rsquo;s Law as a way to measure the result of a given optimization. It&rsquo;s especially useful to compare different optimizations and see the maximum performance each optimization provides for your system. Another cool thing is that Amdahl&rsquo;s Law works for parallel or serial programs.
It has a few implications:
 Make the common case fast Optimizations wil have less and less effects (Law of diminishing returns)  Here&rsquo;s an interesting video about it.
        </p>
    </div>
</a>

		
			<a href="https://todayilearned.dev/posts/hash-deep-merge/" class="catalogue-item">
    <div>
        <time datetime="2019-05-07 12:50:45 -0400 EDT" class="catalogue-time">May 7, 2019</time>
        <h1 class="catalogue-title">hash-deep-merge</h1>
        <div class="catalogue-line"></div>

        <p>
            TIL that Hash#deep_merge accepts a block in which you can specify how values from the same key should be merged:
h1 = { a: { b: 1 }, c: 2} h2 = { a: { d: 3 }, c: 4} h1.deep_merge(h2) # =&gt; { a: { b: 1, d: 3 }, c: 4 } h1.deep_merge(h2) { |k, v1, v2| v1 + v2 } # =&gt; { a: { b: 1, d: 3 }, c: 6 } 
        </p>
    </div>
</a>

		
			<a href="https://todayilearned.dev/posts/ramdisk-tests/" class="catalogue-item">
    <div>
        <time datetime="2019-05-04 15:30:10 -0400 EDT" class="catalogue-time">May 4, 2019</time>
        <h1 class="catalogue-title">ramdisk tests</h1>
        <div class="catalogue-line"></div>

        <p>
            TIL about running tests through a spawned database instance off a RAM disk. This has been applied for a long time, but completely flew under my radar. An early example of this setup with Rails and MySQL can be seen here.
The idea is to make your test databaseâ€™s storage live in memory instead of on-disk since it makes for faster reads and writes, even when considering the use of SSD.
        </p>
    </div>
</a>

		
			<a href="https://todayilearned.dev/posts/webpack-tree-shaking/" class="catalogue-item">
    <div>
        <time datetime="2019-05-01 18:50:00 -0400 EDT" class="catalogue-time">May 1, 2019</time>
        <h1 class="catalogue-title">webpack tree shaking</h1>
        <div class="catalogue-line"></div>

        <p>
            TIL about tree shaking in webpack as a way to eliminate dead code.
The way this is accomplished is by using the sideEffects package.json property.
{ &#34;name&#34;: &#34;your-project&#34;, &#34;sideEffects&#34;: false }  &quot;sideEffects&quot;: false in this context means that our code doesn&rsquo;t have special behaviour when imported other than exposing one or more exports. If that&rsquo;s not the case we can whitelist these special files:
{ &#34;name&#34;: &#34;your-project&#34;, &#34;sideEffects&#34;: [ &#34;.
        </p>
    </div>
</a>

		
			<a href="https://todayilearned.dev/posts/ulids/" class="catalogue-item">
    <div>
        <time datetime="2019-04-29 08:30:10 -0400 EDT" class="catalogue-time">April 29, 2019</time>
        <h1 class="catalogue-title">ulids</h1>
        <div class="catalogue-line"></div>

        <p>
            TIL about ULID, which stands for &ldquo;Universally Unique Lexicographically Sortable Identifier&rdquo;. Like UUID, ULID have 128 bits but are represented as a 26 character string, as opposed to 36.
An ULID is composed of a timestamp + random sequence of bits:
01AN4Z07BY 79KA1307SR9X4MV3 |----------| |----------------| Timestamp Randomness 48bits 80bits  It gives the system the possibility of sorting identifiers unlike UUIDs, but still makes it difficult to guess an identifier and the amount of resources our system has, which are two potential problems of using sequential ids.
        </p>
    </div>
</a>

		
			<a href="https://todayilearned.dev/posts/cp-u-flag/" class="catalogue-item">
    <div>
        <time datetime="2019-04-26 18:20:10 -0400 EDT" class="catalogue-time">April 26, 2019</time>
        <h1 class="catalogue-title">cp -u flag</h1>
        <div class="catalogue-line"></div>

        <p>
            TIL about the -u flag for cp. It will only copy files that don&rsquo;t exist, or are newer than their existing counterparts in the destination directory.
$ cp -u *.txt app_dir It&rsquo;s a nice replacement to the interactive flag (-i) if we know we want this behaviour.
        </p>
    </div>
</a>

		
			<a href="https://todayilearned.dev/posts/roaring-bitmap/" class="catalogue-item">
    <div>
        <time datetime="2019-04-13 19:50:10 -0400 EDT" class="catalogue-time">April 13, 2019</time>
        <h1 class="catalogue-title">roaring bitmap</h1>
        <div class="catalogue-line"></div>

        <p>
            TIL about roaring bitmap, a hybrid data structure.
It&rsquo;s a data structure that is especially suited to compute the intersection, union and the difference between sets. It uses different approaches depending on how your data is distributed like uncompressed bitmaps or sorted arrays.
The way this is done is by dividing the data into chunks of 2^16 integers and using a different strategy for each chunk depending on the data distribution.
        </p>
    </div>
</a>

		
	</div>
	
	<div class="pagination">
		
			<a href="/posts/page/2/" class="left arrow">&#8592;</a>
		
		
			<a href="/posts/page/4/" class="right arrow">&#8594;</a>
		
	
		<span>3</span>
	</div>
</main>


        		<footer>
			<span>
			&copy; <time datetime="2020">2020</time> <a href="https://twitter.com/bernardo_amc" target="_blank">@bernardo_amc</a>.
			</span>
		</footer>

    </body>
</html>
